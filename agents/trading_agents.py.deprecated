"""
10个专业交易智能体实现
基于一进二战法的A股交易策略
"""

import asyncio
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
import json
import logging
from enum import Enum
import aiohttp
from collections import defaultdict

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class SignalType(Enum):
    """信号类型"""
    STRONG_BUY = "strong_buy"     # 强烈买入
    BUY = "buy"                   # 买入
    HOLD = "hold"                 # 持有
    SELL = "sell"                 # 卖出
    STRONG_SELL = "strong_sell"   # 强烈卖出


@dataclass
class TradingSignal:
    """交易信号"""
    symbol: str
    signal_type: SignalType
    confidence: float  # 信心度 0-1
    reason: str
    timestamp: datetime
    metadata: Dict[str, Any] = field(default_factory=dict)


class BaseAgent(ABC):
    """基础智能体"""
    
    def __init__(self, name: str, config: Dict[str, Any] = None):
        self.name = name
        self.config = config or {}
        self.state = {}
        self.history = []
        
    @abstractmethod
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """分析数据并生成信号"""
        pass
    
    def update_state(self, key: str, value: Any):
        """更新状态"""
        self.state[key] = value
        
    def get_state(self, key: str, default=None):
        """获取状态"""
        return self.state.get(key, default)
    
    def log_action(self, action: str, details: Dict[str, Any]):
        """记录行为"""
        self.history.append({
            "timestamp": datetime.now(),
            "action": action,
            "details": details
        })


# 1. 市场生态分析智能体
class MarketEcologyAgent(BaseAgent):
    """市场生态分析智能体"""
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__("MarketEcologyAgent", config)
        self.hot_sectors = []
        self.market_sentiment = 0.5  # 0-1, 0.5为中性
        
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """
        分析市场生态
        包括：市场热点、板块轮动、题材概念、主力动向
        """
        symbol = data.get("symbol")
        market_data = data.get("market_data", {})
        
        # 分析市场热点
        hot_sectors = await self._analyze_hot_sectors(market_data)
        
        # 分析板块轮动
        sector_rotation = await self._analyze_sector_rotation(market_data)
        
        # 分析市场情绪
        market_sentiment = await self._analyze_market_sentiment(market_data)
        
        # 分析资金流向
        money_flow = await self._analyze_money_flow(market_data)
        
        # 综合评分
        score = self._calculate_ecology_score(
            hot_sectors, sector_rotation, market_sentiment, money_flow
        )
        
        # 生成信号
        signal_type = self._determine_signal(score)
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            confidence=abs(score),
            reason=f"市场生态评分: {score:.2f}, 热点板块: {hot_sectors[:3]}",
            timestamp=datetime.now(),
            metadata={
                "hot_sectors": hot_sectors,
                "market_sentiment": market_sentiment,
                "money_flow": money_flow
            }
        )
    
    async def _analyze_hot_sectors(self, market_data: Dict[str, Any]) -> List[str]:
        """分析热点板块"""
        # 获取板块涨幅榜
        sectors = market_data.get("sectors", {})
        
        # 计算板块强度
        sector_strength = {}
        for sector, data in sectors.items():
            strength = data.get("change_pct", 0) * data.get("volume_ratio", 1)
            sector_strength[sector] = strength
        
        # 排序获取热点板块
        hot_sectors = sorted(sector_strength.items(), key=lambda x: x[1], reverse=True)
        hot_sectors = [s[0] for s in hot_sectors[:10]]
        
        self.hot_sectors = hot_sectors
        return hot_sectors
    
    async def _analyze_sector_rotation(self, market_data: Dict[str, Any]) -> Dict[str, float]:
        """分析板块轮动"""
        rotation_score = {}
        
        # 获取历史板块表现
        for sector in self.hot_sectors:
            # 计算板块动量
            momentum = self._calculate_sector_momentum(sector, market_data)
            rotation_score[sector] = momentum
        
        return rotation_score
    
    async def _analyze_market_sentiment(self, market_data: Dict[str, Any]) -> float:
        """分析市场情绪"""
        # 涨跌比
        advance_decline = market_data.get("advance_decline_ratio", 0.5)
        
        # 成交量变化
        volume_change = market_data.get("volume_change", 0)
        
        # 涨停板数量
        limit_up_count = market_data.get("limit_up_count", 0)
        limit_down_count = market_data.get("limit_down_count", 0)
        
        # 综合计算情绪指标
        sentiment = (
            advance_decline * 0.3 +
            min(volume_change / 100, 1) * 0.2 +
            min(limit_up_count / 100, 1) * 0.3 -
            min(limit_down_count / 50, 0.2) * 0.2
        )
        
        self.market_sentiment = max(0, min(1, sentiment))
        return self.market_sentiment
    
    async def _analyze_money_flow(self, market_data: Dict[str, Any]) -> Dict[str, float]:
        """分析资金流向"""
        money_flow = {
            "main_inflow": market_data.get("main_money_inflow", 0),
            "main_outflow": market_data.get("main_money_outflow", 0),
            "retail_inflow": market_data.get("retail_money_inflow", 0),
            "retail_outflow": market_data.get("retail_money_outflow", 0),
            "net_inflow": market_data.get("net_money_inflow", 0)
        }
        return money_flow
    
    def _calculate_ecology_score(self, hot_sectors, sector_rotation, 
                                 market_sentiment, money_flow) -> float:
        """计算生态评分"""
        score = 0
        
        # 热点板块加分
        if hot_sectors:
            score += len(hot_sectors) * 0.05
        
        # 市场情绪加分
        score += (market_sentiment - 0.5) * 2
        
        # 资金流入加分
        net_inflow = money_flow.get("net_inflow", 0)
        score += min(net_inflow / 1000000000, 0.3)  # 10亿封顶
        
        return max(-1, min(1, score))
    
    def _calculate_sector_momentum(self, sector: str, market_data: Dict[str, Any]) -> float:
        """计算板块动量"""
        sector_data = market_data.get("sectors", {}).get(sector, {})
        
        # 5日涨幅
        change_5d = sector_data.get("change_5d", 0)
        # 20日涨幅
        change_20d = sector_data.get("change_20d", 0)
        
        # 动量 = 短期涨幅 - 长期涨幅/2
        momentum = change_5d - change_20d / 2
        
        return momentum
    
    def _determine_signal(self, score: float) -> SignalType:
        """根据评分确定信号"""
        if score > 0.6:
            return SignalType.STRONG_BUY
        elif score > 0.2:
            return SignalType.BUY
        elif score > -0.2:
            return SignalType.HOLD
        elif score > -0.6:
            return SignalType.SELL
        else:
            return SignalType.STRONG_SELL


# 2. 竞价博弈分析智能体
class AuctionGameAgent(BaseAgent):
    """竞价博弈分析智能体"""
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__("AuctionGameAgent", config)
        
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """
        分析竞价阶段的博弈
        包括：封板意愿、资金博弈、开盘预判
        """
        symbol = data.get("symbol")
        auction_data = data.get("auction_data", {})
        
        # 分析竞价量能
        volume_analysis = self._analyze_auction_volume(auction_data)
        
        # 分析价格走势
        price_trend = self._analyze_price_trend(auction_data)
        
        # 分析封板强度
        seal_strength = self._analyze_seal_strength(auction_data)
        
        # 分析资金性质
        money_nature = self._analyze_money_nature(auction_data)
        
        # 计算竞价得分
        score = self._calculate_auction_score(
            volume_analysis, price_trend, seal_strength, money_nature
        )
        
        signal_type = self._determine_signal(score)
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            confidence=abs(score),
            reason=f"竞价博弈评分: {score:.2f}, 封板强度: {seal_strength:.2f}",
            timestamp=datetime.now(),
            metadata={
                "volume_analysis": volume_analysis,
                "seal_strength": seal_strength,
                "money_nature": money_nature
            }
        )
    
    def _analyze_auction_volume(self, auction_data: Dict[str, Any]) -> Dict[str, float]:
        """分析竞价量能"""
        return {
            "total_volume": auction_data.get("auction_volume", 0),
            "volume_ratio": auction_data.get("auction_volume_ratio", 1),
            "big_order_ratio": auction_data.get("big_order_ratio", 0)
        }
    
    def _analyze_price_trend(self, auction_data: Dict[str, Any]) -> str:
        """分析价格走势"""
        price_changes = auction_data.get("price_changes", [])
        
        if not price_changes:
            return "neutral"
        
        # 计算价格趋势
        if price_changes[-1] > price_changes[0]:
            if price_changes[-1] > price_changes[0] * 1.05:
                return "strong_up"
            return "up"
        elif price_changes[-1] < price_changes[0]:
            if price_changes[-1] < price_changes[0] * 0.95:
                return "strong_down"
            return "down"
        
        return "neutral"
    
    def _analyze_seal_strength(self, auction_data: Dict[str, Any]) -> float:
        """分析封板强度"""
        # 封单金额
        seal_amount = auction_data.get("seal_amount", 0)
        # 流通市值
        circulating_value = auction_data.get("circulating_value", 1)
        
        # 封板率 = 封单金额 / 流通市值
        seal_ratio = seal_amount / circulating_value if circulating_value > 0 else 0
        
        # 封板强度评分 (0-1)
        seal_strength = min(seal_ratio * 100, 1)  # 1%封板率满分
        
        return seal_strength
    
    def _analyze_money_nature(self, auction_data: Dict[str, Any]) -> str:
        """分析资金性质"""
        # 大单占比
        big_order_ratio = auction_data.get("big_order_ratio", 0)
        
        if big_order_ratio > 0.6:
            return "institution"  # 机构
        elif big_order_ratio > 0.3:
            return "mixed"  # 混合
        else:
            return "retail"  # 散户
    
    def _calculate_auction_score(self, volume_analysis, price_trend, 
                                 seal_strength, money_nature) -> float:
        """计算竞价评分"""
        score = 0
        
        # 量能加分
        volume_ratio = volume_analysis.get("volume_ratio", 1)
        score += min((volume_ratio - 1) * 0.2, 0.3)
        
        # 价格趋势加分
        trend_scores = {
            "strong_up": 0.4,
            "up": 0.2,
            "neutral": 0,
            "down": -0.2,
            "strong_down": -0.4
        }
        score += trend_scores.get(price_trend, 0)
        
        # 封板强度加分
        score += seal_strength * 0.3
        
        # 资金性质加分
        nature_scores = {
            "institution": 0.2,
            "mixed": 0.1,
            "retail": -0.1
        }
        score += nature_scores.get(money_nature, 0)
        
        return max(-1, min(1, score))
    
    def _determine_signal(self, score: float) -> SignalType:
        """根据评分确定信号"""
        if score > 0.6:
            return SignalType.STRONG_BUY
        elif score > 0.2:
            return SignalType.BUY
        elif score > -0.2:
            return SignalType.HOLD
        elif score > -0.6:
            return SignalType.SELL
        else:
            return SignalType.STRONG_SELL


# 3. 资金性质识别智能体
class MoneyNatureAgent(BaseAgent):
    """资金性质识别智能体"""
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__("MoneyNatureAgent", config)
        
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """
        识别资金性质
        包括：游资、机构、散户等不同资金的特征和意图
        """
        symbol = data.get("symbol")
        trade_data = data.get("trade_data", {})
        
        # 分析成交特征
        trade_features = self._analyze_trade_features(trade_data)
        
        # 识别游资特征
        hot_money_score = self._identify_hot_money(trade_data)
        
        # 识别机构特征
        institution_score = self._identify_institution(trade_data)
        
        # 识别散户特征
        retail_score = self._identify_retail(trade_data)
        
        # 判断主导资金
        dominant_money = self._determine_dominant_money(
            hot_money_score, institution_score, retail_score
        )
        
        # 计算资金质量评分
        quality_score = self._calculate_money_quality(
            dominant_money, hot_money_score, institution_score
        )
        
        signal_type = self._determine_signal(quality_score, dominant_money)
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            confidence=abs(quality_score),
            reason=f"主导资金: {dominant_money}, 资金质量: {quality_score:.2f}",
            timestamp=datetime.now(),
            metadata={
                "dominant_money": dominant_money,
                "hot_money_score": hot_money_score,
                "institution_score": institution_score,
                "retail_score": retail_score
            }
        )
    
    def _analyze_trade_features(self, trade_data: Dict[str, Any]) -> Dict[str, Any]:
        """分析成交特征"""
        return {
            "avg_trade_amount": trade_data.get("avg_trade_amount", 0),
            "big_trade_ratio": trade_data.get("big_trade_ratio", 0),
            "trade_frequency": trade_data.get("trade_frequency", 0),
            "price_impact": trade_data.get("price_impact", 0)
        }
    
    def _identify_hot_money(self, trade_data: Dict[str, Any]) -> float:
        """识别游资特征"""
        score = 0
        
        # 特征1：快进快出
        turnover_rate = trade_data.get("turnover_rate", 0)
        if turnover_rate > 0.2:  # 换手率>20%
            score += 0.3
        
        # 特征2：集中扫货
        concentration = trade_data.get("buy_concentration", 0)
        if concentration > 0.6:
            score += 0.3
        
        # 特征3：拉升速度快
        rise_speed = trade_data.get("rise_speed", 0)
        if rise_speed > 0.05:  # 5分钟涨5%
            score += 0.2
        
        # 特征4：龙虎榜常客
        dragon_tiger = trade_data.get("dragon_tiger_appear", False)
        if dragon_tiger:
            score += 0.2
        
        return min(score, 1)
    
    def _identify_institution(self, trade_data: Dict[str, Any]) -> float:
        """识别机构特征"""
        score = 0
        
        # 特征1：大单为主
        big_order_ratio = trade_data.get("big_order_ratio", 0)
        if big_order_ratio > 0.4:
            score += 0.3
        
        # 特征2：买卖均衡
        buy_sell_balance = trade_data.get("buy_sell_balance", 0.5)
        if 0.45 < buy_sell_balance < 0.55:
            score += 0.2
        
        # 特征3：持续建仓
        continuous_buy = trade_data.get("continuous_buy_days", 0)
        if continuous_buy > 3:
            score += 0.3
        
        # 特征4：低换手率
        turnover_rate = trade_data.get("turnover_rate", 0)
        if turnover_rate < 0.05:
            score += 0.2
        
        return min(score, 1)
    
    def _identify_retail(self, trade_data: Dict[str, Any]) -> float:
        """识别散户特征"""
        score = 0
        
        # 特征1：小单为主
        small_order_ratio = trade_data.get("small_order_ratio", 0)
        if small_order_ratio > 0.6:
            score += 0.3
        
        # 特征2：追涨杀跌
        chase_ratio = trade_data.get("chase_ratio", 0)
        if chase_ratio > 0.6:
            score += 0.3
        
        # 特征3：交易分散
        trade_dispersion = trade_data.get("trade_dispersion", 0)
        if trade_dispersion > 0.7:
            score += 0.2
        
        # 特征4：情绪化交易
        emotional_trading = trade_data.get("emotional_trading", 0)
        if emotional_trading > 0.5:
            score += 0.2
        
        return min(score, 1)
    
    def _determine_dominant_money(self, hot_money: float, 
                                 institution: float, retail: float) -> str:
        """判断主导资金"""
        scores = {
            "hot_money": hot_money,
            "institution": institution,
            "retail": retail
        }
        
        return max(scores.items(), key=lambda x: x[1])[0]
    
    def _calculate_money_quality(self, dominant_money: str,
                                hot_money: float, institution: float) -> float:
        """计算资金质量评分"""
        quality_weights = {
            "hot_money": 0.7,
            "institution": 0.9,
            "retail": 0.3
        }
        
        base_quality = quality_weights.get(dominant_money, 0.5)
        
        # 混合资金加分
        if hot_money > 0.3 and institution > 0.3:
            base_quality += 0.2
        
        return min(base_quality, 1)
    
    def _determine_signal(self, quality_score: float, dominant_money: str) -> SignalType:
        """根据资金质量确定信号"""
        if dominant_money == "retail" and quality_score < 0.5:
            return SignalType.SELL
        
        if quality_score > 0.7:
            return SignalType.STRONG_BUY
        elif quality_score > 0.5:
            return SignalType.BUY
        elif quality_score > 0.3:
            return SignalType.HOLD
        else:
            return SignalType.SELL


# 4. 动态风控智能体
class DynamicRiskAgent(BaseAgent):
    """动态风控智能体"""
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__("DynamicRiskAgent", config)
        self.risk_limits = config.get("risk_limits", {})
        
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """
        动态风险控制
        包括：市场风险、个股风险、仓位风险、流动性风险
        """
        symbol = data.get("symbol")
        position_data = data.get("position_data", {})
        market_data = data.get("market_data", {})
        
        # 计算市场风险
        market_risk = self._calculate_market_risk(market_data)
        
        # 计算个股风险
        stock_risk = self._calculate_stock_risk(data)
        
        # 计算仓位风险
        position_risk = self._calculate_position_risk(position_data)
        
        # 计算流动性风险
        liquidity_risk = self._calculate_liquidity_risk(data)
        
        # 综合风险评估
        total_risk = self._calculate_total_risk(
            market_risk, stock_risk, position_risk, liquidity_risk
        )
        
        # 生成风控信号
        signal_type = self._determine_risk_signal(total_risk)
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            confidence=1 - total_risk,
            reason=f"综合风险: {total_risk:.2f}, 市场风险: {market_risk:.2f}",
            timestamp=datetime.now(),
            metadata={
                "total_risk": total_risk,
                "market_risk": market_risk,
                "stock_risk": stock_risk,
                "position_risk": position_risk,
                "liquidity_risk": liquidity_risk
            }
        )
    
    def _calculate_market_risk(self, market_data: Dict[str, Any]) -> float:
        """计算市场风险"""
        risk = 0
        
        # VIX恐慌指数
        vix = market_data.get("vix", 20)
        risk += min(vix / 100, 0.3)
        
        # 市场下跌风险
        market_trend = market_data.get("market_trend", 0)
        if market_trend < -0.02:  # 市场下跌2%
            risk += 0.2
        
        # 成交量萎缩风险
        volume_change = market_data.get("volume_change", 0)
        if volume_change < -0.3:  # 成交量下降30%
            risk += 0.2
        
        return min(risk, 1)
    
    def _calculate_stock_risk(self, data: Dict[str, Any]) -> float:
        """计算个股风险"""
        risk = 0
        
        # 波动率风险
        volatility = data.get("volatility", 0)
        risk += min(volatility * 2, 0.3)
        
        # 技术面风险
        technical_score = data.get("technical_score", 0.5)
        if technical_score < 0.3:
            risk += 0.2
        
        # 基本面风险
        fundamental_score = data.get("fundamental_score", 0.5)
        if fundamental_score < 0.3:
            risk += 0.2
        
        # 负面消息风险
        negative_news = data.get("negative_news_count", 0)
        risk += min(negative_news * 0.1, 0.3)
        
        return min(risk, 1)
    
    def _calculate_position_risk(self, position_data: Dict[str, Any]) -> float:
        """计算仓位风险"""
        risk = 0
        
        # 仓位集中度风险
        concentration = position_data.get("concentration", 0)
        if concentration > 0.3:  # 单股超30%
            risk += 0.3
        
        # 杠杆风险
        leverage = position_data.get("leverage", 1)
        if leverage > 1.5:
            risk += (leverage - 1) * 0.3
        
        # 浮亏风险
        unrealized_loss = position_data.get("unrealized_loss_ratio", 0)
        if unrealized_loss > 0.1:  # 浮亏超10%
            risk += unrealized_loss
        
        return min(risk, 1)
    
    def _calculate_liquidity_risk(self, data: Dict[str, Any]) -> float:
        """计算流动性风险"""
        risk = 0
        
        # 成交量风险
        avg_volume = data.get("avg_volume", 0)
        position_size = data.get("position_size", 0)
        
        if avg_volume > 0:
            days_to_exit = position_size / (avg_volume * 0.2)  # 假设占日成交20%
            if days_to_exit > 3:
                risk += min(days_to_exit / 10, 0.5)
        
        # 买卖价差风险
        bid_ask_spread = data.get("bid_ask_spread", 0)
        risk += min(bid_ask_spread * 10, 0.3)
        
        return min(risk, 1)
    
    def _calculate_total_risk(self, market_risk: float, stock_risk: float,
                             position_risk: float, liquidity_risk: float) -> float:
        """计算总风险"""
        # 加权平均
        total = (
            market_risk * 0.25 +
            stock_risk * 0.35 +
            position_risk * 0.25 +
            liquidity_risk * 0.15
        )
        
        return min(total, 1)
    
    def _determine_risk_signal(self, total_risk: float) -> SignalType:
        """根据风险等级确定信号"""
        if total_risk > 0.7:
            return SignalType.STRONG_SELL  # 高风险，强烈卖出
        elif total_risk > 0.5:
            return SignalType.SELL  # 中高风险，卖出
        elif total_risk > 0.3:
            return SignalType.HOLD  # 中等风险，持有
        elif total_risk > 0.2:
            return SignalType.BUY  # 低风险，可买入
        else:
            return SignalType.STRONG_BUY  # 极低风险，强烈买入


# 5. 综合决策智能体
class IntegratedDecisionAgent(BaseAgent):
    """综合决策智能体"""
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__("IntegratedDecisionAgent", config)
        self.agent_weights = config.get("agent_weights", {})
        
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """
        综合各智能体信号，生成最终交易决策
        """
        symbol = data.get("symbol")
        agent_signals = data.get("agent_signals", {})
        
        # 收集各智能体信号
        signal_scores = self._collect_signal_scores(agent_signals)
        
        # 检查信号一致性
        consistency = self._check_signal_consistency(agent_signals)
        
        # 加权综合评分
        final_score = self._calculate_weighted_score(signal_scores)
        
        # 考虑一致性调整
        if consistency < 0.5:  # 信号分歧大
            final_score *= 0.7  # 降低信心
        
        # 生成最终决策
        decision = self._make_final_decision(final_score, consistency)
        
        return TradingSignal(
            symbol=symbol,
            signal_type=decision,
            confidence=abs(final_score) * consistency,
            reason=f"综合评分: {final_score:.2f}, 一致性: {consistency:.2f}",
            timestamp=datetime.now(),
            metadata={
                "final_score": final_score,
                "consistency": consistency,
                "agent_scores": signal_scores
            }
        )
    
    def _collect_signal_scores(self, agent_signals: Dict[str, TradingSignal]) -> Dict[str, float]:
        """收集各智能体信号分数"""
        scores = {}
        
        signal_values = {
            SignalType.STRONG_BUY: 1.0,
            SignalType.BUY: 0.5,
            SignalType.HOLD: 0.0,
            SignalType.SELL: -0.5,
            SignalType.STRONG_SELL: -1.0
        }
        
        for agent_name, signal in agent_signals.items():
            if signal:
                score = signal_values.get(signal.signal_type, 0)
                scores[agent_name] = score * signal.confidence
        
        return scores
    
    def _check_signal_consistency(self, agent_signals: Dict[str, TradingSignal]) -> float:
        """检查信号一致性"""
        if not agent_signals:
            return 0
        
        signal_types = [s.signal_type for s in agent_signals.values() if s]
        
        if not signal_types:
            return 0
        
        # 计算信号方向
        directions = []
        for signal_type in signal_types:
            if signal_type in [SignalType.STRONG_BUY, SignalType.BUY]:
                directions.append(1)
            elif signal_type in [SignalType.STRONG_SELL, SignalType.SELL]:
                directions.append(-1)
            else:
                directions.append(0)
        
        # 计算一致性（标准差的反向指标）
        if len(directions) > 1:
            std = np.std(directions)
            consistency = 1 - min(std, 1)
        else:
            consistency = 1
        
        return consistency
    
    def _calculate_weighted_score(self, signal_scores: Dict[str, float]) -> float:
        """计算加权综合评分"""
        # 默认权重
        default_weights = {
            "MarketEcologyAgent": 0.20,
            "AuctionGameAgent": 0.15,
            "MoneyNatureAgent": 0.20,
            "DynamicRiskAgent": 0.25,
            "ExecutionMonitorAgent": 0.10,
            "LearningEvolutionAgent": 0.10
        }
        
        weights = self.agent_weights or default_weights
        
        weighted_sum = 0
        weight_total = 0
        
        for agent_name, score in signal_scores.items():
            weight = weights.get(agent_name, 0.1)
            weighted_sum += score * weight
            weight_total += weight
        
        if weight_total > 0:
            return weighted_sum / weight_total
        
        return 0
    
    def _make_final_decision(self, final_score: float, consistency: float) -> SignalType:
        """做出最终决策"""
        # 高一致性时的阈值
        if consistency > 0.7:
            if final_score > 0.6:
                return SignalType.STRONG_BUY
            elif final_score > 0.2:
                return SignalType.BUY
            elif final_score < -0.6:
                return SignalType.STRONG_SELL
            elif final_score < -0.2:
                return SignalType.SELL
            else:
                return SignalType.HOLD
        
        # 低一致性时更保守
        else:
            if final_score > 0.8:
                return SignalType.BUY
            elif final_score < -0.8:
                return SignalType.SELL
            else:
                return SignalType.HOLD


# 其余5个智能体的简化实现框架

# 6. 执行监控智能体
class ExecutionMonitorAgent(BaseAgent):
    """执行监控智能体"""
    
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """监控订单执行状态、成交质量、滑点控制"""
        symbol = data.get("symbol")
        execution_data = data.get("execution_data", {})
        
        # 监控成交质量
        execution_quality = execution_data.get("execution_quality", 0.5)
        
        # 监控滑点
        slippage = execution_data.get("slippage", 0)
        
        # 计算执行评分
        score = execution_quality - abs(slippage) * 2
        
        signal_type = SignalType.HOLD if -0.2 < score < 0.2 else (
            SignalType.BUY if score > 0.2 else SignalType.SELL
        )
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            confidence=abs(score),
            reason=f"执行质量: {execution_quality:.2f}, 滑点: {slippage:.4f}",
            timestamp=datetime.now()
        )


# 7. 学习进化智能体
class LearningEvolutionAgent(BaseAgent):
    """学习进化智能体"""
    
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """基于历史数据学习和策略进化"""
        symbol = data.get("symbol")
        history_data = data.get("history_data", {})
        
        # 分析历史成功率
        success_rate = history_data.get("success_rate", 0.5)
        
        # 策略优化建议
        optimization_score = history_data.get("optimization_score", 0)
        
        score = success_rate + optimization_score
        
        signal_type = SignalType.HOLD if -0.2 < score < 0.2 else (
            SignalType.BUY if score > 0.2 else SignalType.SELL
        )
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            confidence=abs(score),
            reason=f"历史成功率: {success_rate:.2f}",
            timestamp=datetime.now()
        )


# 8. 知识管理智能体
class KnowledgeManagementAgent(BaseAgent):
    """知识管理智能体"""
    
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """管理交易知识和经验"""
        symbol = data.get("symbol")
        
        # 查询相似历史案例
        similar_cases = data.get("similar_cases", [])
        
        # 计算历史案例成功率
        if similar_cases:
            success_count = sum(1 for case in similar_cases if case.get("profitable", False))
            success_rate = success_count / len(similar_cases)
        else:
            success_rate = 0.5
        
        signal_type = SignalType.BUY if success_rate > 0.6 else (
            SignalType.SELL if success_rate < 0.4 else SignalType.HOLD
        )
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            confidence=abs(success_rate - 0.5) * 2,
            reason=f"历史相似案例成功率: {success_rate:.2f}",
            timestamp=datetime.now()
        )


# 9. 通信协调智能体
class CommunicationCoordinatorAgent(BaseAgent):
    """通信协调智能体"""
    
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """协调多智能体通信和任务分配"""
        symbol = data.get("symbol")
        
        # 这个智能体主要负责协调，不直接生成交易信号
        # 返回中性信号
        return TradingSignal(
            symbol=symbol,
            signal_type=SignalType.HOLD,
            confidence=0.5,
            reason="协调智能体不直接生成交易信号",
            timestamp=datetime.now()
        )


# 10. 绩效评估智能体
class PerformanceEvaluationAgent(BaseAgent):
    """绩效评估智能体"""
    
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """评估策略和交易绩效"""
        symbol = data.get("symbol")
        performance_data = data.get("performance_data", {})
        
        # 计算夏普比率
        sharpe_ratio = performance_data.get("sharpe_ratio", 0)
        
        # 计算最大回撤
        max_drawdown = performance_data.get("max_drawdown", 0)
        
        # 绩效评分
        score = sharpe_ratio - abs(max_drawdown)
        
        signal_type = SignalType.HOLD if -0.2 < score < 0.2 else (
            SignalType.BUY if score > 0.2 else SignalType.SELL
        
        return TradingSignal(
            symbol=symbol,
            signal_type=signal_type,
            confidence=abs(score),
            reason=f"夏普比率: {sharpe_ratio:.2f}, 最大回撤: {max_drawdown:.2f}",
            timestamp=datetime.now()


# 多智能体协作管理器
class MultiAgentManager:
    """多智能体协作管理器"""
    
    def __init__(self):
        self.agents = {
            "market_ecology": MarketEcologyAgent(),
            "auction_game": AuctionGameAgent(),
            "money_nature": MoneyNatureAgent(),
            "dynamic_risk": DynamicRiskAgent(),
            "integrated_decision": IntegratedDecisionAgent(),
            "execution_monitor": ExecutionMonitorAgent(),
            "learning_evolution": LearningEvolutionAgent(),
            "knowledge_management": KnowledgeManagementAgent(),
            "communication_coordinator": CommunicationCoordinatorAgent(),
            "performance_evaluation": PerformanceEvaluationAgent()
        }
        
    async def analyze(self, data: Dict[str, Any]) -> TradingSignal:
        """
        多智能体协作分析
        
        Args:
            data: 市场数据
            
        Returns:
            最终交易信号
        """
        # 并行执行各智能体分析
        agent_signals = {}
        
        tasks = []
        for name, agent in self.agents.items():
            if name != "integrated_decision":  # 综合决策最后执行
                tasks.append(self._analyze_with_agent(name, agent, data))
        
        # 等待所有智能体完成
        results = await asyncio.gather(*tasks)
        
        for name, signal in results:
            agent_signals[name] = signal
        
        # 综合决策
        decision_data = data.copy()
        decision_data["agent_signals"] = agent_signals
        
        final_signal = await self.agents["integrated_decision"].analyze(decision_data)
        
        return final_signal
    
    async def _analyze_with_agent(self, name: str, agent: BaseAgent, 
                                 data: Dict[str, Any]) -> Tuple[str, TradingSignal]:
        """执行单个智能体分析"""
        try:
            signal = await agent.analyze(data)
            logger.info(f"{name} generated signal: {signal.signal_type.value}")
            return name, signal
        except Exception as e:
            logger.error(f"{name} analysis failed: {e}")
            return name, None


if __name__ == "__main__":
    # 测试代码
    async def test():
        manager = MultiAgentManager()
        
        # 模拟数据
        test_data = {
            "symbol": "000001",
            "market_data": {
                "sectors": {
                    "tech": {"change_pct": 0.03, "volume_ratio": 1.5},
                    "finance": {"change_pct": 0.02, "volume_ratio": 1.2}
                },
                "advance_decline_ratio": 0.6,
                "volume_change": 20,
                "limit_up_count": 50,
                "limit_down_count": 10
            },
            "auction_data": {
                "auction_volume": 1000000,
                "auction_volume_ratio": 1.5,
                "seal_amount": 50000000,
                "circulating_value": 1000000000
            },
            "trade_data": {
                "turnover_rate": 0.15,
                "big_order_ratio": 0.45
            },
            "position_data": {
                "concentration": 0.2,
                "leverage": 1.0
            }
        }
        
        signal = await manager.analyze(test_data)
        print(f"Final signal: {signal.signal_type.value}")
        print(f"Confidence: {signal.confidence:.2f}")
        print(f"Reason: {signal.reason}")
    
    # 运行测试
    # asyncio.run(test())